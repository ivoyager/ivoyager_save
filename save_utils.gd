# save_utils.gd
# This file is part of I, Voyager
# https://ivoyager.dev
# *****************************************************************************
# Copyright 2017-2025 Charlie Whitfield
# I, Voyager is a registered trademark of Charlie Whitfield in the US
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# *****************************************************************************
class_name IVSaveUtils
extends Object

## Static utility class that provides methods related to game save/load and
## object "persist" properties.
##
## See [IVTreeSaver] for explanation of tree persistence.

## Persist mode specified by an object's [param PERSIST_MODE] constant, if
## present. Value 0 is hard-coded as the "no persist" identifier, so that
## [code]object.get(&"PERSIST_MODE")[/code] is always null or 0 (false in
## boolean context) for a non-persist object.
enum PersistMode {
	NO_PERSIST = 0, ## Non-persist object.
	PERSIST_PROPERTIES_ONLY, ## Object will not be freed (Node only; must have stable NodePath).
	PERSIST_PROCEDURAL, ## Object will be freed and rebuilt on game load (Node or RefCounted).
}


## A static list of names of the constants that define persist properties in a
## persist object. In base configuration these are [param &"PERSIST_PROPERTIES"]
## and [param &"PERSIST_PROPERTIES2"]. The extra list name is provided for
## subclassing.
static var persist_property_lists: Array[StringName] = [
	&"PERSIST_PROPERTIES",
	&"PERSIST_PROPERTIES2",
]


static var _debug_persist_register: Dictionary[int, WeakRef] = {}



## Returns one of [enum PersistMode] enums (NO_PERSIST if constant
## PERSIST_MODE is not present).
static func get_persist_mode(object: Object) -> PersistMode:
	return type_convert(object.get(&"PERSIST_MODE"), TYPE_INT)


## Returns true if [param object] is [enum PersistMode.PERSIST_PROPERTIES_ONLY]
## or [enum PersistMode.PERSIST_PROCEDURAL], otherwise false.
static func is_persist_object(object: Object) -> bool:
	return type_convert(object.get(&"PERSIST_MODE"), TYPE_BOOL) # 0 or null -> false


## Returns true if [param object] is [enum PersistMode.PERSIST_PROCEDURAL],
## otherwise false.
static func is_procedural_object(object: Object) -> bool:
	const PERSIST_PROCEDURAL := PersistMode.PERSIST_PROCEDURAL
	return type_convert(object.get(&"PERSIST_MODE"), TYPE_INT) == PERSIST_PROCEDURAL


## Frees all procedural [Node]s at or below [param node].
static func free_procedural_nodes_recursive(node: Node) -> void:
	if is_procedural_object(node):
		node.queue_free() # children will also be freed!
		return
	for child in node.get_children():
		if is_persist_object(child):
			free_procedural_nodes_recursive(child)


## Clones object properties using [member persist_property_lists] in the
## [param origin] class. [param origin] and [param clone] must have the same
## persist properties. Arrays and Dictionaries are duplicated (deep = true).
## However, Objects will be set without duplication.
static func clone_persist_properties(origin: Object, clone: Object) -> void:
	for properties_array in persist_property_lists:
		if not properties_array in origin:
			continue
		var properties: Array[StringName] = origin.get(properties_array)
		for property in properties:
			var value: Variant = origin.get(property)
			var type := typeof(value)
			if type == TYPE_ARRAY:
				var origin_array: Array = value
				value = origin_array.duplicate(true)
			elif type == TYPE_DICTIONARY:
				var origin_dict: Dictionary = value
				value = origin_dict.duplicate(true)
			clone.set(property, value)


## Generates an array of persist property values from [param object] using
## [member persist_property_lists]. Using this method in combination with
## [method set_persist_properties] is equivalent to [method clone_persist_properties].
static func get_persist_properties(origin: Object) -> Array:
	var array := []
	for properties_array in persist_property_lists:
		if not properties_array in origin:
			continue
		var properties: Array[StringName] = origin.get(properties_array)
		for property in properties:
			var value: Variant = origin.get(property)
			var type := typeof(value)
			if type == TYPE_ARRAY:
				var origin_array: Array = value
				value = origin_array.duplicate(true)
			elif type == TYPE_DICTIONARY:
				var origin_dict: Dictionary = value
				value = origin_dict.duplicate(true)
			array.append(value)
	return array


## Sets properties from an array generated by [method get_persist_properties].
static func set_persist_properties(clone: Object, array: Array) -> void:
	var i := 0
	for properties_array in persist_property_lists:
		if not properties_array in clone:
			continue
		var properties: Array[StringName] = clone.get(properties_array)
		for property in properties:
			clone.set(property, array[i])
			i += 1


## Generates an array of persist property names in [param object] using
## [member persist_property_lists].
static func get_persist_property_names(object: Object) -> Array[StringName]:
	var array: Array[StringName] = []
	for properties_array in persist_property_lists:
		if not properties_array in object:
			continue
		var properties: Array[StringName] = object.get(properties_array)
		array.append_array(properties)
	return array


## Returns an instantiated [Object] or the root [Node] of an instantiated scene.[br][br]
##
## [param arg] can be a [Script], [PackedScene], or [String]. If it is a String,
## it must be a valid path to a Script or PackedScene file resource.[br][br]
##
## If the supplied Script or file-loaded Script has constant [param SCENE] or
## [param SCENE_OVERRIDE], then the constant value is used as path to
## instantiate a scene. 
static func make_object_or_scene(arg: Variant) -> Object:
	var arg_type := typeof(arg)
	var packedscene: PackedScene
	var script: Script
	if arg_type == TYPE_OBJECT:
		if arg is Script:
			script = arg
		elif arg is PackedScene:
			packedscene = arg
		else:
			assert(false, "Unknown object class %s" % arg)
			return null
	else:
		assert(arg is String)
		var path: String = arg
		var script_or_packedscene := get_script_or_packedscene(path)
		if !script_or_packedscene:
			assert(false, "Could not load '%s' as Script or PackedScene" % path)
			return null
		if script_or_packedscene is Script:
			script = script_or_packedscene
		else:
			packedscene = script_or_packedscene
	
	if script:
		var scene_path: String
		if &"SCENE_OVERRIDE" in script:
			scene_path = script.get("SCENE_OVERRIDE")
		elif &"SCENE" in script:
			scene_path = script.get("SCENE")
		if scene_path:
			packedscene = load(scene_path)
			if !packedscene:
				assert(false, "Failed to load scene at '%s'" % scene_path)
				return null
		else:
			@warning_ignore("unsafe_method_access")
			return script.new()
	
	var root_node: Node = packedscene.instantiate()
	if root_node.get_script() != script: # root_node.script may be parent class!
		root_node.set_script(script)
	return root_node

## Returns either a Script or a PackedScene, depending on [param path] file
## extension. Throws error if it fails to load [param path].
static func get_script_or_packedscene(path: String) -> Resource:
	if !path:
		assert(false, "Requires path")
		return null
	if path.ends_with(".tscn") or path.ends_with(".scn"):
		var packedscene: PackedScene = load(path)
		assert(packedscene, "Failed to load PackedScene at '%s'" % path)
		return packedscene
	var script: Script = load(path)
	assert(script, "Failed to load Script at '%s'" % path)
	return script


## Use with [method debug_report_unfreed_procedural_objects] to test procedural
## object freeing, which may fail due to circular references (including signal
## connections) and cause leaks. Indexes all existing procedural objects using
## weak references. After tree destruction and a frame delay, call
## [method debug_report_unfreed_procedural_objects]. All "debug_" functions
## always return true, so they can be wrapped inside assert() to call only in
## editor/debug build.
static func debug_register_persist_objects(root: Node, print_now := false) -> bool:
	_register_persist_object_recursive(root)
	if print_now:
		debug_print_persist_register()
	return true


static func debug_print_persist_register(procedural_only := false) -> bool:
	for id in _debug_persist_register:
		var object: Object = _debug_persist_register[id].get_ref()
		if !object:
			continue
		var is_procedural := is_procedural_object(object)
		if is_procedural and procedural_only:
			continue
		var script: Script = object.get_script()
		var file := script.resource_path.get_file()
		prints(object, file, "" if is_procedural else "(properties only)")
	return true


## Reports unfreed procedural objects and asserts none (by default) after
## previous call(s) to [method debug_register_persist_objects]. All "debug_" functions
## always return true, so they can be wrapped inside assert() to call only in
## editor/debug build.
static func debug_report_unfreed_procedural_objects(assert_none := true) -> bool:
	var is_unfreed_procedural := false
	for id in _debug_persist_register:
		var object: Object = _debug_persist_register[id].get_ref()
		if object and is_procedural_object(object):
			is_unfreed_procedural = true
			break
	if is_unfreed_procedural:
		push_error("Unfreed procedural objects exist. The list will follow...")
		debug_print_persist_register(true)
		assert(!assert_none, "Unfreed procedural objects. See Output for list.")
	_debug_persist_register.clear()
	return true


static func _register_persist_object_recursive(object: Object) -> void:
	assert(is_persist_object(object), "Non-persist Object specified or nested in persist list")
	
	# Index all persist objects.
	var id := object.get_instance_id()
	if _debug_persist_register.has(id):
		return
	_debug_persist_register[id] = weakref(object)
	
	# Get all procedural object references from persist lists, recursive.
	for properties_array_name in persist_property_lists:
		if not properties_array_name in object:
			continue
		var properties_array: Array = object.get(properties_array_name)
		for property: StringName in properties_array:
			var variant: Variant = object.get(property)
			_register_persist_variant_recursive(variant)
	
	# Check all persist nodes, recursive.
	if object is Node:
		var node: Node = object
		assert(node.is_inside_tree(), "Reference to persist node that is not in the tree")
		for child in node.get_children():
			if is_persist_object(child):
				_register_persist_object_recursive(child)


static func _register_persist_variant_recursive(variant: Variant) -> void:
	var type := typeof(variant)
	if type == TYPE_OBJECT:
		var object: Object = variant
		_register_persist_object_recursive(object)
	elif type == TYPE_ARRAY:
		var array: Array = variant
		_register_persist_array_recursive(array)
	elif type == TYPE_DICTIONARY:
		var dict: Dictionary = variant
		_register_persist_dictionary_recursive(dict)


static func _register_persist_array_recursive(array: Array) -> void:
	var array_type := array.get_typed_builtin()
	if array_type == TYPE_OBJECT:
		for object: Object in array:
			_register_persist_object_recursive(object)
	elif array_type == TYPE_ARRAY:
		for nested_array: Array in array:
			_register_persist_array_recursive(nested_array)
	elif array_type == TYPE_DICTIONARY:
		for dict: Dictionary in array:
			_register_persist_dictionary_recursive(dict)
	elif array_type == TYPE_NIL:
		for variant: Variant in array:
			_register_persist_variant_recursive(variant)


static func _register_persist_dictionary_recursive(dict: Dictionary) -> void:
	const REGISTER_TYPES: Array[int] = [TYPE_OBJECT, TYPE_ARRAY, TYPE_DICTIONARY, TYPE_NIL]
	var key_type := dict.get_typed_key_builtin()
	if REGISTER_TYPES.has(key_type):
		var keys := Array(dict.keys(), key_type, &"", null)
		_register_persist_array_recursive(keys)
	var value_type := dict.get_typed_value_builtin()
	if REGISTER_TYPES.has(value_type):
		var values := Array(dict.values(), value_type, &"", null)
		_register_persist_array_recursive(values)
